// qopenglbuffer.sip generated by MetaSIP
//
// This file is part of the QtOpenGL Python extension module.
//
// Copyright (c) 2026 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt6.
// 
// This file may be used under the terms of the GNU General Public License
// version 3.0 as published by the Free Software Foundation and appearing in
// the file LICENSE included in the packaging of this file.  Please review the
// following information to ensure the GNU General Public License version 3.0
// requirements will be met: http://www.gnu.org/copyleft/gpl.html.
// 
// If you do not wish to use this file under the terms of the GPL version 3.0
// then you may purchase a commercial license.  For more information contact
// info@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


class QOpenGLBuffer
{
%TypeHeaderCode
#include <qopenglbuffer.h>
%End

public:
    enum Type
    {
        VertexBuffer,
        IndexBuffer,
        PixelPackBuffer,
        PixelUnpackBuffer,
    };

    QOpenGLBuffer();
    explicit QOpenGLBuffer(QOpenGLBuffer::Type type);
    QOpenGLBuffer(const QOpenGLBuffer &other);
    ~QOpenGLBuffer();

    enum UsagePattern
    {
        StreamDraw,
        StreamRead,
        StreamCopy,
        StaticDraw,
        StaticRead,
        StaticCopy,
        DynamicDraw,
        DynamicRead,
        DynamicCopy,
    };

    enum Access
    {
        ReadOnly,
        WriteOnly,
        ReadWrite,
    };

    QOpenGLBuffer::Type type() const;
    QOpenGLBuffer::UsagePattern usagePattern() const;
    void setUsagePattern(QOpenGLBuffer::UsagePattern value);
    bool create();
    bool isCreated() const;
    void destroy();
    bool bind();
    void release();
    static void release(QOpenGLBuffer::Type type);
    GLuint bufferId() const;
    int size() const /__len__/;
    bool read(int offset, void *data, int count);
    void write(int offset, const void *data, int count);
    void allocate(const void *data, int count);
    void allocate(int count);
    void *map(QOpenGLBuffer::Access access);
    bool unmap();

    enum RangeAccessFlag /BaseType=Flag/
    {
        RangeRead,
        RangeWrite,
        RangeInvalidate,
        RangeInvalidateBuffer,
        RangeFlushExplicit,
        RangeUnsynchronized,
    };

    typedef QFlags<QOpenGLBuffer::RangeAccessFlag> RangeAccessFlags;
    void *mapRange(int offset, int count, QOpenGLBuffer::RangeAccessFlags access);
%If (Qt_6_5_0 -)
    void swap(QOpenGLBuffer &other);
%End
};
